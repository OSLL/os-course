\begin{frame}
\frametitle{Надежность и консистентность}
\begin{itemize}
  \item Нам бы хотелось, чтобы ФС были надежными - не теряли
  пользовательские данные
  \begin{itemize}
    \item мы не будем обсуждать вариант, когда вы уронили диск в костер или
    смыли;
    \item т. е. мы не рассматриваем ситуацию, когда диск вышел из строя.
  \end{itemize}
  \item Какие же проблемы у нас остаются?
  \begin{itemize}
    \item неожиданное отключение питания, т. е. работа ФС была прервана
    неожиданно.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Какие могут возникнуть проблемы?}
\begin{itemize}
  \item Вспомните работу с B+ деревом:
  \begin{itemize}
    \item мы можем прервать вставку/удаление в/из B+ дерева на середине;
    \item т. е. когда мы добавили/удалили ключ в/из листа, но не восстановили
    инварианты дерева до конца;
    \item в лучшем случае дерево не будет корректным B+ деревом, в худшем мы
    потеряем часть ключей и произойдет утечка места на диске.
  \end{itemize}
  \item Удаление файла из каталога:
  \begin{itemize}
    \item нужно удалить имя файла из списка имен файлов/каталогов в каталоге;
    \item нужно освободить Inode, используемый для файла;
    \item нужно освободить место занятое содержимым файла.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Доступные гарантии}
\begin{itemize}
  \item Мы можем считать, что запись одного сектора (512 байт) атомарна:
  \begin{itemize}
    \item сектор либо полностью записался либо не записался вообще;
    \item то что вы послали устройству команду на запись одного сектора, не
    значит, что запись реально произошла.
  \end{itemize}
  \item Существует команда - барьер:
  \begin{itemize}
    \item вы можете послать устройству специальную команду сброса кеша/буферов;
    \item по завершении команды, гарантируется, что все записи отправленные до
    нее реально завершились.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Soft update и fsck}
\begin{itemize}
  \item Основная идея: выполняем все операции в таком порядке, чтобы:
  \begin{itemize}
    \item если нас прервут, то ФС будет в рабочем (пусть и не очень
    консистентном состоянии);
    \item все неконсистентности можно найти и поправить.
  \end{itemize}
  \item Утилита fsck сканирует всю ФС, ищет и исправляет проблемы:
  \begin{itemize}
    \item должна просканировать всю ФС, что может занять время;
    \item может иногда помочь в случае поломки диска, о которых мы не говорим.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Пример: удание файла из каталога}
\begin{itemize}
  \item В первую очередь удаляем имя файла из списка файлов/каталогов в
  каталоге
  \begin{itemize}
    \item если нас прервут сразу после этой операции, то у нас один из Inode-ов
    может остаться занятым, хотя ссылок на него не будет;
    \item место занятое файлом не будет освобождено;
    \item в остальном состояние ФС в рабочем состоянии;
    \item fsck может найти Inode-ы и сектора на которые нет ссылок и освободить
    их.
  \end{itemize}
  \item Если сначала освободить Inode или место занятое файлом?
  \begin{itemize}
    \item тогда в каталоге останется ссылка на невалидный Inode и при чтении
    или, еще хуже, записи мы обратимся к чужим секторам на диске.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Финальные замечания про soft update}
\begin{itemize}
  \item Soft update и fsck сравнительно сложны в реализации:
  \begin{itemize}
    \item требуется аккуратно продумать порядок обновления и строго его
    соблюдать - заставлять диск сбрасывать кеш.
  \end{itemize}
  \item Soft update и fsck работают сравнительноо медленно:
  \begin{itemize}
    \item постоянные сбросы кешей диска не способствуют скорости работы;
    \item fsck должен сканировать всю ФС, чтобы понять на что есть ссылки, а на
    что нет.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Write Ahead Log (WAL, Journal)}
\begin{itemize}
  \item Перед тем как выполнить какую-то операцию мы можем записать в
  специальное место диска (журнал), что мы хотим сделать
  \begin{itemize}
    \item обновляем структуры ФС только после того как запись была
    зафиксирована на диске;
    \item записи должны быть структурированы так, чтобы мы могли отличать целые
    законченные записи от незаконченных (например, мы можем в конце записи
    добавить специальный сектор - признак завершения записи).
  \end{itemize}
  \item Что делать если нас прервали?
  \begin{itemize}
    \item мы просто повторяем операции записанные в журнале ("проигрываем"
    журнал);
    \item после чего очищаем журнал.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Идемпотентность записей в журнале}
\begin{itemize}
  \item Что если нас прервут, пока мы проигрываем запись из журнала?
  \begin{itemize}
    \item если записи в журнале идемпотентны, то ничего;
    \item т. е. при следующем запуске мы заново "проимгрываем" журнал.
  \end{itemize}
  \item Операция идемпотентна, если мы можем применить ее несколько раз без
  изменений результата
  \begin{itemize}
    \item записать данную порцию данных в данный сектор диска - идемпотентная
    операция;
    \item мы можем повторять запись сколько угодно раз, практически, без
    последствий.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Copy-On-Write}
\begin{itemize}
  \item Вместо того, чтобы обновлять данные на диске In-Place будем создавать
  копии в памяти, обновлять копии и выписывать копии в новое место на диске
  \begin{itemize}
    \item после того как у нас готова исправленная версия данных нужно "просто"
    перенаправить ссылку со старой версии данных в новую;
    \item перенаправить ссылку = записать, т. е. опять Copy-On-Write;
    \item когда эта перезапись должна остановиться? Когда мы дойдем до,
    некоторого "корня" (например, корня дерева, или суперблока ФС), который
    можно записать атомарно.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Применение COW}
\begin{itemize}
  \item Copy-On-Write используется в ZFS и Btrfs (и не только):
  \begin{itemize}
    \item Btrfs использует COW B+ деревья (Ohad Rodeh, BTRFS: The Linux B-tree
    Filesystem, там же ссылки на алгоритм COW B+ деревьев);
    \item ZFS - другой, уже классческий, пример (Jeff Bonwick, тот же, что
    придумал SLAB);
    \item обе ФС умеют делать snapshot-ы (версионирование) - приятный бонус
    использования COW.
  \end{itemize}
\end{itemize}
\end{frame}
