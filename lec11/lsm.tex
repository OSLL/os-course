\begin{frame}
\frametitle{Log-Structured Merge Tree (LSM)}
\begin{itemize}
  \item Недостатки B+ деревьев:
  \begin{itemize}
    \item вставка и удаление в/из B+ дерева сложные;
    \item параллельная работа с B+ деревьями сложная.
  \end{itemize}
  \item Можно сделать проще:
  \begin{itemize}
    \item пожертвовав алгоритмической сложностью поиска;
    \item получив в замен "эффективную" параллельную работу.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Нам понадобятся}
\begin{itemize}
  \item Упорядоченный словарь в памяти с операцией вставки:
  \begin{itemize}
    \item если ключ уже есть в словаре, то нужно заменить занчение;
    \item подойдет любое дерево поиска, но плохо для параллельной обработки;
    \item популярный вариант Skiplist - сравнительно легко параллелится.
  \end{itemize}
  \item Обратите внимание:
  \begin{itemize}
    \item нам не нужна операция удаления;
    \item но будет полезной операция обмена двух словарей.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Нам понадобятся}
\begin{itemize}
  \item Упорядоченный словарь на диске:
  \begin{itemize}
    \item мы должны уметь создавать словарь из \emph{упорядоченного} набора
    пар (ключ, значение);
    \item ветвистое дерево поиска (на подобие B+ дерева) очень легко построить
    из упорядоченного набора пар;
    \item естественно, словарь должен поддерживать поиск;
    \item а так же итерацию по ключам в отсортированном порядке.
  \end{itemize}
  \item Обратите внимание:
  \begin{itemize}
    \item нам не нужны операции вставки и удаления из словаря;
    \item мы создаем словарь за раз, после чего он никогда не меняется.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Собираем все вместе}
\begin{itemize}
  \item Возьмем один словарь в памяти и несколько (скажем N) словарей на диске:
  \begin{itemize}
    \item начальное состояние когда все эти словари пустые;
    \item всех назовем и пронумеруем, словарь в памяти будет $C_0$, первый
    словарь на диске будет $C_1$, последний словарь на диске будет $C_N$.
  \end{itemize}
  \item С каждый словарем кроме последнего свяжем ограничение на максимальный
  размер словаря:
  \begin{itemize}
    \item обычно размеры словарей растут как члены геометрический прогрессии;
    \item если размер словаря в памяти $S$ и знаменатель прогрессии $q$, то
    размер $C_1$ ограничивается $Sq$, размер $C_2$ ограничивается $Sq^2$ и так
    далее;
    \item будем называть эти ограничения $S_i$, где $i$ - номер словаря.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Вставка в LSM}
\begin{itemize}
  \item Вставка всегда осуществляется в $C_0$ (т. е. словарь в памяти):
  \begin{itemize}
    \item естественно $C_0$ при этом растет, и когда-нибудь станет больше $S_0$;
    \item в этом случае нам нужно слить $C_0$ и $C_1$ в один словарь на диске;
    \item полученный словарь заменит старый $C_1$, а $C_0$ нужно опустошить.
  \end{itemize}
  \item Аналогичным образом мы поступаем когда $C_i$ перерастает $S_i$
  \begin{itemize}
    \item сливаем $C_i$ и $C_{i+1}$ в новую версию $C_{i+1}$;
    \item разница только в том, что теперь оба словаря изначально на диске.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Удаление из LSM}
\begin{itemize}
  \item У нас нет ни операции удаления из $C_0$ ни для всех остальных $C_i$
  \begin{itemize}
    \item вместо этого мы можем вставить в $C_0$ ключ, который мы хотим
    удалить, но со специальным маркером;
    \item каждый раз, когда мы видим этот маркер мы знаем, что ключ удален.
  \end{itemize}
  \item Можно ли физически удалить ключ и освободить место?
  \begin{itemize}
    \item когда мы сливаем $C_i$ и $C_{i+1}$ мы можем увидеть два одинаковых
    ключа;
    \item в результирующий словарь нужно добавить только один, ключ из $C_i$;
    \item если мы сливаем $C_{N-1}$ и $C_{N}$, то ключи с маркером выписывать
    не нужно - таким образом мы физически удалим ключ из словаря.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Поиск в LSM}
\begin{itemize}
  \item Поиск в LSM делаем последовательно от $C_0$ до $C_N$:
  \begin{itemize}
    \item до тех пор пока не найдем нужный ключ;
    \item если ключ с маркером, то значит ключа нет и можно остановиться.
  \end{itemize}
  \item Поиск в LSM алгоритмически хуже, чем в B+ дереве, что взамен?
  \begin{itemize}
    \item простота - LSM деревья используют только простые примитивы (никакой
    перебалансировки и прочего);
    \item все $C_i$ для $i \in \left[1..N\right]$ не изменяются - не нужна
    синхронизация (главное, чтобы их не удалили пока, кто-то в них ищет);
    \item $C_0$ не требует операции удаления - проще реализовать параллельную
    версию.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Финальные замечания про LSM}
\begin{itemize}
  \item Была описана только общая идея, детали могут отличаться:
  \begin{itemize}
    \item можно использовать разные структуры данных для $C_0$ и $C_i$;
    \item можно использовать несколько словарей в памяти (зачастую их два,
    это нужно чтобы не останавливать вставки/удаления пока происходит слияние
    $C_0$ и $C_1$);
    \item можно задавать разные ограничения на размер словарей и сливать
    больше чем два словаря за раз.
  \end{itemize}
  \item Используется довольно широко:
  \begin{itemize}
    \item LevelDB/RocksDB, вероятно, еще в очень многих Key-Value/NoSQL/Any
    other buzzword;
    \item Apache Cassandra;
    \item Apache HBase/BigTable.
  \end{itemize}
\end{itemize}
\end{frame}
