\begin{frame}
\frametitle{Индексные структуры данных}
\begin{itemize}
  \item Для быстрого поиска файла/каталога внутри каталога или смещения на диске
  по смещению внутри файла можно использовать подходящую структуру данных:
  \begin{itemize}
    \item чтобы быстро находить и открывать файлы по имени;
    \item чтобы читать/писать файлы не по-порядку.
  \end{itemize}
  \item Имя подхоядщий словарь мы вообще можем хранить все дерево каталогов в
  одном словаре:
  \begin{itemize}
    \item отображаем номер Inode родительского каталога и имя на номер Inode
    файла/каталога внутри каталога;
    \item с таким словарем нам даже не нужно заранее выделять место под таблицу
    Inode-ов - мы можем просто хранить их в таком словаре.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Деревья поиска}
\begin{itemize}
  \item Бинарные деревья поиска - классический вариант индексной структуры
  данных в памяти:
  \begin{itemize}
    \item Red-Black деревья;
    \item AVL деревья;
    \item Splay деревья;
    \item декартовы деревья.
  \end{itemize}
  \item Бинарные деревья поиска не годятся в качестве индекса на диске
  \begin{itemize}
    \item они неэффективны для блочного интерфейса (меньше 512 байт за раз
    читать/писать мы все равно не можем);
    \item бинарные деревья поиска очень высокие (даже идеально
    сбалансированные).
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Ветвистые деревья}
\begin{itemize}
  \item Если бинарные деревья поиска слишком высокие, то просто будем
  использовать N-арные, где N будет 10, 100, 1000...
  \begin{itemize}
    \item если каждый узел может хранить больше 2 ссылок на дочерние узлы, то
    высота дерева может быть меньше;
    \item за одно обращение к диску мы можем читать сразу N ссылок.
  \end{itemize}
  \item $B$-деревья - идеально сбалансированные N-арные деревья поиска:
  \begin{itemize}
    \item со временем $B$-деревья получили много вариаций: $B+$, $B^*$,
    $B^\epsilon$;
    \item вариации $B$-деревьев используются повсеместно для индексации (в ФС,
    базах данных, Key-Value Store-ах и прочих).
  \end{itemize}
\end{itemize}
\end{frame}
