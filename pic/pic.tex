\section{Контроллер прерываний}

Данный раздел относится исключительно к прерываниям от внешних устройств, и
рассказывает ту часть истории, которая происходит снаружи CPU\footnote{Впрочем
снаружи CPU в данном случае мало что значит, контроллер прерываний с тем же
успехом может находится и прямо в CPU.}. К контроллеру прерываний подключаются
устройства, которые хотят генерировать прерывания, а контроллер прерываний уже
отправляет сообщения процессору. В сообщении каким-то образом сообщается какой
номер прерывания (какую запись IDT) использовать для вызова обработчика
прерывания.

Контроллер преываний выполняет арбитраж, т. е. выстраивает запросы от устройств
в очередь, согласно некоторому приоритету. Впрочем детали приоритизации запросов
от устройств нас не особо волнуют на данном уровне понимания. Зато начальная
настройка контроллера прерываний, отображение на записи IDT нас очень волнуют.

Мы будем использовать для экспериментов устаревший контроллер прерываний из
серии intel 8259. Каскад из двух таких чипов использовался в IBM PC начиная с
версии AT, т. е. в предке того, что мы сейчас называем персональным компьютером.
Зачастую современные персональные компьютеры сохраняют обратную совместимость,
т. е. поведение этих intel 8259 чипов эмулируется современными контроллерами
прерываний используемыми в персональных компьютерах. Соответственно, вся
конкретная информация относится только к intel 8259, в то время как общая
картина меняется с изменением контроллера не так сильно.

\subsection{Каскад контроллеров прерываний}

Как уже отмечалось, в IBM PC два intel 8259 чипа объединялись в каскад.
Конфигурация этого каскада всегда фиксированная, но вообще intel 8259 позволял
использовать различные конфигурации, например, объединять больше двух
контроллеров.

В каскаде есть Master и Slave (или несколько Slave-ов). Можете считать, что
Master контроллер подключается к процессору, в то время как Slave контроллер
подключается к Master-у. Устройства могут быть подключены как к Slave
контроллеру, так и к Master контроллеру, если у него есть свободные ноги (не
занятые подключением Slave-ов). Однако надо понимать, что если устройство
подключено к Slave, то Slave потом передаст сигнал Master-у, т. е. на Slave
можно очень отдальенно смотреть как на устройство подключенное к Master.

Итак нас интересует конкретно конфигурация каскада для IBM PC. В этой
конфигурации единственный Slave подключается ко 2-му выходу Master, считая с 0.
Очень схематично эта конфигурация изображена на Рис.~\ref{fig:pic_casc}.

\begin{figure}
  \centering
  \includegraphics[width=0.9\textwidth]{pic_casc.png}
  \caption{Каскад intel 8259 в IBM PC AT.}
  \label{fig:pic_casc}
\end{figure}

\subsection{Взаимодействие с контроллером прерываний}

Для общения с контроллером прерываний используется специальная фича архитектуры
x86 - пространство ввода/вывода\footnote{Я знаю не так много архитектур, где
кроме пространства памяти, есть еще и отдельное пространство ввода вывода.
Другая известная мне архитектура это AVR.}. Для обращения к отдельным местам
пространства ввода/вывода используются специальные инструкции in и out. Не
трудно догадаться, что in читает что-то из некоторого адреса в пространстве
ввода/вывода, а out записывает. Зачастую отдельные адреса пространства
ввода/вывода называют портами, далее мы будем придерживаться этого же имени.

Чтобы настроить контроллер прерываний нужно знать какие порты используются
контроллером для настройки и что значат отдельные записи в эти порты, ну и
конечно чего вы хотите от контроллера прерываний. Оставшаяся часть раздела
будет посвещенна именно этому.

Для общения с каждым из двух контроллеров используются свои порты ввода/вывода.
Для Master-а используется порты 0x20 и 0x21, а для Slave-а используются порты
0xA0 и 0xA1. Все порты размером в 1 8-ми битный байт. Среди двух портов выделяют
командный и порт для данных. Например, 0x20 командный порт для Master, в то
время как 0xA0 командный порт для Slave. В командный порт нужно записать
некоторое командное слово, после чего аргументы нужные этой команде нужно
записать в порт данных и так для каждого контроллера.

\subsection{Начальная конфигурация контроллера прерываний}

Цель конфигурации контроллера для нас, это задать отображение входов контроллера
прерываний на записи в IDT. К сожалению, по крайней мере изначально, intel 8259
создавался как более или менее универасльное устройство, которое будет
использоваться не только в IBM PC AT. Поэтому начальная конфигурация задает
чуть больше параметров, чем просто отображение входов контроллера на записи IDT.

Каждый раз, когда в командный регистр записывается слово в установленным 4-м
битом, это восприниматеся как команда инициализации. Остальные интересные нам
биты отвечают за:

\begin{itemize}
  \item IC4 (бит 0) - если установлен, то команда инициализации ожидает 3 байта
  данных, если сброшен, то только 2; мы рассмотрим подробнее, зачем нужен каждый
  байт, сейчас вам достаточно знать, что нам нужны все 3;
  \item SNGL (бит 1) - если установлен, то используется только один контроллер,
  в противном случае они объединены в каскад\footnote{Да, контроллерам нужно
  сообщать, что они объединены в каскад.};
  \item LTIM (бит 3) - если установлен, то контроллер прерываний будет ожидать
  level triggered сигналы от устройств, в противном случае edge triggered; то
  какой вариант использовать зависит от устройства, в нашем случае всегда
  используется edge triggered прерывания.
\end{itemize}

Т. е. в дополнение к 4 биту, в байте, который нужно записать в командный порт
каждого из контроллеров, нужно установить бит 0.

Далее оба контроллера будут ожидать 3 байта данных, которые нужно поочереди
записать в порт данных каждого из контроллеров. Рассмотрим на каждое из них.

Первый байт, который нужно записать в порт данныз для команды инициализации,
это номер 1-ой записи в IDT соответсвующей 0-ому входу контроллера прерываний,
т. е. собственно этот байт и задает нужное нам отображение. Для каждого из
контроллеров это отображение задается отдельно и так как вам удобно, до тех
пор пока вы соблюдаете пару простых правил:
\begin{itemize}
  \item номера записей в IDT, на которые вы отображаете входы контроллера,
  должны быть больше или равны 32 (первые 32 записи начиная с 0
  зарезервированны);
  \item не стоит делать так, чтобы отображения разных котроллеров пересекались.
\end{itemize}

Т. е. если вы хотите отобразить входы котроллеров прерываний на номера с 32, то
в порт данных Master нужно записать 32, а в порт данных Slave нужно записать 40.

Второй байт определяет конфигурацию каскада и имеет немного разное значение для
Master и Slave. Для Master нужно в этом байте каждый бит соответсвует входу
контроллера (их всего 8). Для каждого входа к которому подключен Slave нужно
установить 1 в соответствующем бите. В нашем случае 2-ой бит (считая с 0) должен
быть равен 1, а остальные сброшены.

Для Slave нужно записать к какому входу Master подключен Slave, на этот раз
просто числом, а не в виде битовой маски. Т. е. в нашем случае нужно записать
число 2.

Последний байт отвечает за целый набор разных функций, большинство из которых
нам не нужны. Из всего байта нам важен только 0 бит, он должен быть установлен
в 1 для x86 архитектуры\footnote{Более точно для 80x86, в те времена этот
контроллер прерываний и появился.}.

\subsection{End of interrupt}

Когда обработчик прерывания завершил обработку, он должен сообщить контроллеру
прерываний, что обработка закончена, таким образом контроллер прерываний будет
знать, что пара генерировать следующее прерывание, если какое-то из устройств
этого попросило\footnote{Я в данном случае намеренно опускаю вопрос
приоритезации и упрощаю рассказ.}.

EOI бывает двух разных видов: направленный (Specific) и ненаправленный
(Non-Specific). Нам подойдет любой из них. Направленный EOI включает номер ноги,
подтверждение для которой мы хотим послать, ненаправленный определяет ее
автоматически\footnote{И нас устраивает способ, которым контроллер прерываний
это делает.}.

Для отправки EOI опять же нужно записать байт в командный регистр. Для
направленного EOI биты 5 и 6 (считая с 0) должны быть равны 0, а младшие 3 бита
должны содержать номер входа. Для ненаправленного EOI только бит 5 должен быть
установлен в 1, а остальные сброшены в 0.

Как уже отмечалось вы можете использовать любой вариант - это не существенно для
нас. А вот что важно помнить, так это то, что у нас используется каскад из двух
контроллеров прерываний, и если прерывание сгенерировано устройством
подключенным к Slave, то Slave дополнительно пошлет сигнал на Master, и,
соответственно, послать EOI нужна обоим контроллерам.

Кроме того обратите внимание, что исключения и программные прерывания никакого
отношения к контроллеру прерываний не имеют, и для таких прерываний никакого
EOI посылать не нужно.

\subsection{Маскировка прерываний}

Мы можем замаскировать отдельные входы контроллера прерываний. Это делается
очень просто и для этого нам даже не нужно писать команду в командный порт.
Все что нужно это записать битовую маску в порт данных. В этой битовой маске
входам, которые нужно замаскировать должна соответствовать 1, а тем, которые
нужно разрешить должен соответствовать 0.

Пока вы не знаете к какимм входам какое устройство подключено и не настроили
соответсвующее устройство, вход, к которому оно подключено, лучше замаскировать.
Т. е. полезно сразу после настройки контроллера прерываний замаскировать все
прерывания и включать по мере настройки устройств.

\subsection{Вывод}

После прочтения этой части у вас в голове должна быть уже полная картина, т. е.
настройка процессора и настройка контроллера прерываний, как маскировать
прерывания на процессоре и как маскировать отдельные входы контоллера
прерываний, как входы контроллера прерываний отображаются на записи в IDT, как,
когда и зачем нужно посылать EOI контроллеру прерываний.
