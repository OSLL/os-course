\begin{frame}
\frametitle{Проблема достижения консенсуса}
\begin{itemize}
  \item Процессы должны согласиться на одном значении
  \begin{itemize}
    \item изначально у каждого процесса есть некоторое свое значение;
    \item процессы должны выбрать из всех значений какое-то одно.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Требования к решению}
\begin{itemize}
  \item Согласованность
  \begin{itemize}
    \item все корректные процессы должны согласиться на одном и том же значении.
  \end{itemize}
  \item Целостность
  \begin{itemize}
    \item значение должно быть предложено одним из процессов.
  \end{itemize}
  \item Завершаемость:
  \begin{itemize}
    \item все корректные процессы должны принять решение в конечном итоге.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Проблема двух генералов}
\begin{itemize}
  \item Есть две армии под командованием двух генералов
  \begin{itemize}
    \item и как обычно бывает в армии - они не замышляют ничего хорошего;
    \item генералы должны договориться о времени атаки на некий город.
  \end{itemize}
  \item При этом есть ограничения:
  \begin{itemize}
    \item генералы могут обмениваться сообщениями используя гонцов;
    \item гонцов могут перехватить и сообщение не будет доставлено.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Обмен сообщениями и подтверждения}
\begin{itemize}
  \item Пусть один из генералов предложил время и отправил гонца к другому
  \begin{itemize}
    \item может ли он считать, что время согласовано?
    \item очевидно нет, т. к. сообщение могло потеряться.
  \end{itemize}
  \item Пусть в ответ на сообщение нам отвечают подтверждением получения:
  \begin{itemize}
    \item пусть второй генерал получил сообщение со временем и отправил ответ;
    \item может ли второй генерал считать, что время атаки согласованно?
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Договориться нельзя}
\begin{itemize}
  \item Допустим для задачи есть решение состоящие из обмена $N$ сообщениями
  \begin{itemize}
    \item последнее сообщение могло потеряться, но результат не должен
    измениться, т. к. корректное решение должно быть готово к потерям.
  \end{itemize}
  \item Получается последнее сообщение не было нужно?
  \begin{itemize}
    \item удалив его получим решение за $N - 1$ сообщение;
    \item и так далее.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Каналы связи ненадежны}
\begin{itemize}
  \item В действительности каналы связи не гарантируют доставку сообщений без
  потерь
  \begin{itemize}
    \item никакой протокол не поможет, если вы сожгли маршрутизатор, обрезали
    провода, не заплатили за Интернет, ...
    \item оставляя особые обстоятельства в стороне TCP, обычно, дает неплохую
    надежность.
  \end{itemize}
  \item В конечном итоге повышение надежности сводится к повторениям:
  \begin{itemize}
    \item мы повторяем отправку сообщений много раз, пока не убедимся что оно
    получено.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Консенсус в асинхронных системах}
\begin{itemize}
  \item Пусть каналы связи надежны, но ограничение на время доставки сообщения
  отсутствуют
  \begin{itemize}
    \item асинхронная модель считается довольно реалистичной.
  \end{itemize}
  \item Но теперь, пусть процессы могут падать
  \begin{itemize}
    \item без падений и потерь сообщений все тривиально;
    \item предполагаем, что после падения процесс никогда не восстанавливается.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Минимальный консенсус с одним падением}
\begin{itemize}
  \item Все процессы предлагают в качестве значения 1 или 0:
  \begin{itemize}
    \item не фундаментальное ограничение - научившись достигать консенсуса на
    одном бите мы сможем достигнуть консенсуса и на серии бит.
  \end{itemize}
  \item Упасть может не более одного процесса:
  \begin{itemize}
    \item если даже с одним падением не справимся, за большее количество браться
    не стоит.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Состояние процесса}
\begin{itemize}
  \item Каждый процесс обладает некоторым внутренним состоянием
  \begin{itemize}
    \item внутреннее состояние и внешние события определяют поведение процесса;
    \item внутреннее состояние процесса неизвестно никому кроме самого процесса.
  \end{itemize}
  \item Если процесс не делает никаких шагов - внутренее состояние не изменяется
  \begin{itemize}
    \item каждый шаг состоит из получения не более чем одного сообщения;
    \item и отправки не более чем одного сообщения.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Состояние системы}
\begin{itemize}
  \item Состояние системы складывается из
  \begin{itemize}
    \item предлагаемого значения каждого процесса;
    \item внутреннего состояния каждого процесса;
    \item множества отправленных, но еще не доставленных сообщений.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Валентность состояния системы}
\begin{itemize}
  \item Состояние бивалентно, если из него можно достичь как решения 0, так и
  решения 1
  \begin{itemize}
    \item т. е. это состояние, в котором решение еще не принято, и может быть
    достигнут любой из двух возможных исходов.
  \end{itemize}
  \item Состояние унивалентно, если из него можно достичь либо только решения 0,
  либо только решения 1
  \begin{itemize}
    \item т. е. решение уже принято, хотя возможно не все об этом знают;
    \item будем называть состояние $i$-валентным, если из него можно достичь
    только решения $i$, где $i$ это либо 0 либо 1.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Бивалентное начальное состояние 1/2}
\begin{itemize}
  \item Начальное состояние - если ни один из процессов не делал ходов
  \begin{itemize}
    \item очевидно они отличаются только предлагаемым значением разных
    процессов - это единственные входные данные, которые у нас есть.
  \end{itemize}
  \item Существуют начальные состония приводящие как к решению 0, так и к
  решению 1:
  \begin{itemize}
    \item если все предлагаемые значения равны 0 (1), то процессы должны
    согласиться на значениии 0 (1).
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Бивалентное начальное состояние 2/2}
\begin{itemize}
  \item Более того должно существовать бивалентное начальное состояние
  \begin{itemize}
    \item допустим противное, т. е. все начальные состояния унивалентны;
    \item мы знаем, что есть как $0$-валентные состояния, так и $1$-валентные;
    \item найдем пару таких начальных состояний, одно из которых $0$-валентное,
    а второе $1$-валентное и они отличаются только предлагаемым значением ровно
    одного процесса;
    \item если этот процесс упадет в самом начале, то эти начальные состояния
    будут неразличимы, но приходят к разным решениям - противоречие.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Сохраняем бивалентное состояние 1/5}
\begin{itemize}
  \item Итак, у нас есть бивалентное состояние, назовем его $С$, и пусть нам дан
  шаг $e$, допустимый в состоянии $C$
  \begin{itemize}
    \item пусть это шаг процесса, который мы обозначим как $p$;
    \item этот шаг останется допустимым пока $p$ его не сделает, т. е. он не
    может неожиданно стать недоступным (отправленные сообщения не исчезают,
    пока их не получат).
  \end{itemize}
  \item Обозначим через $S$ множество состояний достижимых из $C$ \emph{без
  участия шага} $e$ и \emph{без падений}
  \begin{itemize}
    \item обратите внимание, что процесс $p$ может делать шаги, он не может
    сделать только один конкретный шаг $e$;
    \item т. е. процесс $p$ не упал, он просто немного ограничен, потому что
    некоторое сообщение долго доставляется.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Сохраняем бивалентное состояние 2/5}
\begin{itemize}
  \item Обозначим через $e\left(S\right)$ множество состояний полученных из $S$
  применением шага $e$
  \begin{itemize}
    \item допустим, что все состояния в $e\left(S\right)$ унивалентны;
    \item мы можем утверждать, что в $e\left(S\right)$ есть как $0$-валентные
    состояния, так и $1$-валентные (почему?);
    \item т. е. есть такие состояния $C_0$ и $C_1$, что сделав шаг $e$ из $C_0$
    мы получаем $0$-валентное состояние $C_0e$, а сделав шаг $e$ из $C_1$ мы
    получаем $1$-валентное состояние $C_1e$;
    \item все состояния в $S$ делятся на те, которые шаг $e$ переводит в
    $0$-валентное состояние и те, которые шаг $e$ переводит в $1$-валентное.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Сохраняем бивалентное состояние 3/5}
\begin{itemize}
  \item Более того, существует такой шаг $e'$ и состояние $D$ из $S$, что $De$ -
  $0$-валентное состояние, а $De'e$ - $1$-валентное (или наоборот)
  \begin{itemize}
    \item начальное состояние $C$ - бивалентное, и допустим шаг $e$ переводит
    его в $0$-валентное;
    \item есть так же последовательность шагов, которая переводит $C$ в
    состояние, из которого под действием $e$ мы приходим в $1$-валентное
    состояние;
    \item один из шагов в этой последовательности и есть наш $e'$, а одно из
    состояний это и есть наш $D$.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Сохраняем бивалентное состояние 4/5}
\begin{itemize}
  \item Если $e'$ и $e$ - это шаги разных процессов
  \begin{itemize}
    \item тогда состояния $Dee'$ и $De'e$ неразличимы, но так как $De$
    $0$-валентное состояние, то и $Dee'$ тоже $0$-валентное, но $De'e$
    $1$-валетное - противоречие.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Сохраняем бивалентное состояние 5/5}
\begin{itemize}
  \item Если $e'$ и $e$ - это шаги одного процесса $p$
  \begin{itemize}
    \item но по условию один из процессов может упасть, пусть это будет $p$;
    \item рассмотрим конечную последовательно шагов $e_1e_2...e_k$, такую что
    процесс $p$ в ней не участвует ни прямо ни косвенно, т. е. не только не
    получает сообщений, но и сообщения от $p$ никому не доставляются;
    \item с точки зрения других процессов $p$ не отличим от упавшего процесса,
    т. е. последовательность $e_1e_2...e_k$ должна приводить к решению;
    \item $Dee_1e_2...e_k$ и $De'ee_1e_2...e_k$ неразличимы ни для кого кроме
    $p$, а значит принятые решения должны совпадать;
    \item но $De$ $0$-валентное, а $De'e$ $1$-валентное - опять противоречие.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Резюме}
\begin{itemize}
  \item Что мы имеем?
  \begin{enumerate}
    \item существует начальное бивалентное состояние;
    \item существует путь из любого бивалентного состояния в некоторое
    бивалентное использующий заданный шаг;
    \item т. е. мы можем построить \emph{честную} последовательность шагов,
    которая никогда не приведет к решению.
  \end{enumerate}
  \item Т. е. гарантированное достижение консенсуса в асинхронной системе с
  падениями за ограниченное количество шагов не возможно
  \begin{itemize}
    \item этот результат известен как FLP или, иногда, FLP Impossibility;
    \item Michael J. Ficher, Nancy A. Lynch, Michael S. Paterson, 1985.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Применение консенсуса}
\begin{itemize}
  \item К сожалению задача достижения консенсуса эквивалентна многим практически
  значимым задачам
  \begin{itemize}
    \item репликация данных (распределенное хранение одних данных на нескольких 
    узлах со строгими гарантиями консистентности);
    \item выбор лидера;
    \item и некоторые другие.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Достижение консенсуса}
\begin{itemize}
  \item На практике существуют алгоритмы достижения консенсуса жертвующие
  "живостью":
  \begin{itemize}
    \item процессы могут "мешать" друг другу, если условия не благоприятные;
    \item если условия близки к синхронной модели достаточное время, то процессы
    достигают консенсуса;
    \item примеры:
    \begin{itemize}
      \item Paxos (Л. Лэмпорт), вероятно, самый известный и популярный;
      \item Viewstamped Replication (Б. Лисков), ровесник Paxos, но не получил
      большой популярности, хотя описан понятнее;
      \item Raft - задумывался как простая альтернатива Paxos, сравнительно
      новый алгоритм (2013).
    \end{itemize}
  \end{itemize}
\end{itemize}
\end{frame}
